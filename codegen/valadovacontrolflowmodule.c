/* valadovacontrolflowmodule.c generated by valac, the Vala compiler
 * generated from valadovacontrolflowmodule.vala, do not modify */

/* valadovacontrolflowmodule.vala
 *
 * Copyright (C) 2006-2010  Jürg Billeter
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Jürg Billeter <j@bitron.ch>
 */

#include <glib.h>
#include <glib-object.h>
#include <vala.h>
#include <valaccode.h>
#include <stdlib.h>
#include <string.h>
#include <valagee.h>


#define VALA_TYPE_DOVA_BASE_MODULE (vala_dova_base_module_get_type ())
#define VALA_DOVA_BASE_MODULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DOVA_BASE_MODULE, ValaDovaBaseModule))
#define VALA_DOVA_BASE_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DOVA_BASE_MODULE, ValaDovaBaseModuleClass))
#define VALA_IS_DOVA_BASE_MODULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DOVA_BASE_MODULE))
#define VALA_IS_DOVA_BASE_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DOVA_BASE_MODULE))
#define VALA_DOVA_BASE_MODULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DOVA_BASE_MODULE, ValaDovaBaseModuleClass))

typedef struct _ValaDovaBaseModule ValaDovaBaseModule;
typedef struct _ValaDovaBaseModuleClass ValaDovaBaseModuleClass;
typedef struct _ValaDovaBaseModulePrivate ValaDovaBaseModulePrivate;

#define VALA_DOVA_BASE_MODULE_TYPE_EMIT_CONTEXT (vala_dova_base_module_emit_context_get_type ())
#define VALA_DOVA_BASE_MODULE_EMIT_CONTEXT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_DOVA_BASE_MODULE_TYPE_EMIT_CONTEXT, ValaDovaBaseModuleEmitContext))
#define VALA_DOVA_BASE_MODULE_EMIT_CONTEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_DOVA_BASE_MODULE_TYPE_EMIT_CONTEXT, ValaDovaBaseModuleEmitContextClass))
#define VALA_DOVA_BASE_MODULE_IS_EMIT_CONTEXT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_DOVA_BASE_MODULE_TYPE_EMIT_CONTEXT))
#define VALA_DOVA_BASE_MODULE_IS_EMIT_CONTEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_DOVA_BASE_MODULE_TYPE_EMIT_CONTEXT))
#define VALA_DOVA_BASE_MODULE_EMIT_CONTEXT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_DOVA_BASE_MODULE_TYPE_EMIT_CONTEXT, ValaDovaBaseModuleEmitContextClass))

typedef struct _ValaDovaBaseModuleEmitContext ValaDovaBaseModuleEmitContext;
typedef struct _ValaDovaBaseModuleEmitContextClass ValaDovaBaseModuleEmitContextClass;

#define VALA_TYPE_DOVA_STRUCT_MODULE (vala_dova_struct_module_get_type ())
#define VALA_DOVA_STRUCT_MODULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DOVA_STRUCT_MODULE, ValaDovaStructModule))
#define VALA_DOVA_STRUCT_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DOVA_STRUCT_MODULE, ValaDovaStructModuleClass))
#define VALA_IS_DOVA_STRUCT_MODULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DOVA_STRUCT_MODULE))
#define VALA_IS_DOVA_STRUCT_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DOVA_STRUCT_MODULE))
#define VALA_DOVA_STRUCT_MODULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DOVA_STRUCT_MODULE, ValaDovaStructModuleClass))

typedef struct _ValaDovaStructModule ValaDovaStructModule;
typedef struct _ValaDovaStructModuleClass ValaDovaStructModuleClass;
typedef struct _ValaDovaStructModulePrivate ValaDovaStructModulePrivate;

#define VALA_TYPE_DOVA_METHOD_MODULE (vala_dova_method_module_get_type ())
#define VALA_DOVA_METHOD_MODULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DOVA_METHOD_MODULE, ValaDovaMethodModule))
#define VALA_DOVA_METHOD_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DOVA_METHOD_MODULE, ValaDovaMethodModuleClass))
#define VALA_IS_DOVA_METHOD_MODULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DOVA_METHOD_MODULE))
#define VALA_IS_DOVA_METHOD_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DOVA_METHOD_MODULE))
#define VALA_DOVA_METHOD_MODULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DOVA_METHOD_MODULE, ValaDovaMethodModuleClass))

typedef struct _ValaDovaMethodModule ValaDovaMethodModule;
typedef struct _ValaDovaMethodModuleClass ValaDovaMethodModuleClass;
typedef struct _ValaDovaMethodModulePrivate ValaDovaMethodModulePrivate;

#define VALA_TYPE_DOVA_CONTROL_FLOW_MODULE (vala_dova_control_flow_module_get_type ())
#define VALA_DOVA_CONTROL_FLOW_MODULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DOVA_CONTROL_FLOW_MODULE, ValaDovaControlFlowModule))
#define VALA_DOVA_CONTROL_FLOW_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DOVA_CONTROL_FLOW_MODULE, ValaDovaControlFlowModuleClass))
#define VALA_IS_DOVA_CONTROL_FLOW_MODULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DOVA_CONTROL_FLOW_MODULE))
#define VALA_IS_DOVA_CONTROL_FLOW_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DOVA_CONTROL_FLOW_MODULE))
#define VALA_DOVA_CONTROL_FLOW_MODULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DOVA_CONTROL_FLOW_MODULE, ValaDovaControlFlowModuleClass))

typedef struct _ValaDovaControlFlowModule ValaDovaControlFlowModule;
typedef struct _ValaDovaControlFlowModuleClass ValaDovaControlFlowModuleClass;
typedef struct _ValaDovaControlFlowModulePrivate ValaDovaControlFlowModulePrivate;
#define _vala_ccode_node_unref0(var) ((var == NULL) ? NULL : (var = (vala_ccode_node_unref (var), NULL)))
#define _vala_code_node_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_node_unref (var), NULL)))
#define _vala_iterable_unref0(var) ((var == NULL) ? NULL : (var = (vala_iterable_unref (var), NULL)))

struct _ValaDovaBaseModule {
	ValaCodeGenerator parent_instance;
	ValaDovaBaseModulePrivate * priv;
	ValaSymbol* root_symbol;
	ValaDovaBaseModuleEmitContext* emit_context;
	ValaCCodeFile* header_file;
	ValaCCodeFile* cfile;
	ValaList* static_fields;
	gint next_wrapper_id;
	ValaDataType* void_type;
	ValaDataType* bool_type;
	ValaDataType* char_type;
	ValaDataType* int_type;
	ValaDataType* uint_type;
	ValaDataType* string_type;
	ValaClass* object_class;
	ValaClass* type_class;
	ValaClass* value_class;
	ValaClass* string_class;
	ValaStruct* array_struct;
	ValaClass* delegate_class;
	ValaClass* error_class;
};

struct _ValaDovaBaseModuleClass {
	ValaCodeGeneratorClass parent_class;
	void (*generate_struct_declaration) (ValaDovaBaseModule* self, ValaStruct* st, ValaCCodeFile* decl_space);
	void (*generate_delegate_declaration) (ValaDovaBaseModule* self, ValaDelegate* d, ValaCCodeFile* decl_space);
	void (*generate_cparameters) (ValaDovaBaseModule* self, ValaMethod* m, ValaCCodeFile* decl_space, ValaCCodeFunction* func, ValaCCodeFunctionDeclarator* vdeclarator, ValaCCodeFunctionCall* vcall);
	void (*generate_property_accessor_declaration) (ValaDovaBaseModule* self, ValaPropertyAccessor* acc, ValaCCodeFile* decl_space);
	ValaCCodeExpression* (*get_dup_func_expression) (ValaDovaBaseModule* self, ValaDataType* type, ValaSourceReference* source_reference, gboolean is_chainup);
	void (*append_local_free) (ValaDovaBaseModule* self, ValaSymbol* sym, gboolean stop_at_loop, ValaCodeNode* stop_at);
	ValaCCodeExpression* (*get_ref_cexpression) (ValaDovaBaseModule* self, ValaDataType* expression_type, ValaCCodeExpression* cexpr, ValaExpression* expr, ValaCodeNode* node);
	void (*generate_class_declaration) (ValaDovaBaseModule* self, ValaClass* cl, ValaCCodeFile* decl_space);
	void (*generate_interface_declaration) (ValaDovaBaseModule* self, ValaInterface* iface, ValaCCodeFile* decl_space);
	void (*generate_method_declaration) (ValaDovaBaseModule* self, ValaMethod* m, ValaCCodeFile* decl_space);
	ValaCCodeExpression* (*get_implicit_cast_expression) (ValaDovaBaseModule* self, ValaCCodeExpression* source_cexpr, ValaDataType* expression_type, ValaDataType* target_type, ValaExpression* expr);
	gchar* (*get_custom_creturn_type) (ValaDovaBaseModule* self, ValaMethod* m);
	gboolean (*method_has_wrapper) (ValaDovaBaseModule* self, ValaMethod* method);
	void (*add_simple_check) (ValaDovaBaseModule* self, ValaCodeNode* node, gboolean always_fails);
};

struct _ValaDovaStructModule {
	ValaDovaBaseModule parent_instance;
	ValaDovaStructModulePrivate * priv;
};

struct _ValaDovaStructModuleClass {
	ValaDovaBaseModuleClass parent_class;
};

struct _ValaDovaMethodModule {
	ValaDovaStructModule parent_instance;
	ValaDovaMethodModulePrivate * priv;
};

struct _ValaDovaMethodModuleClass {
	ValaDovaStructModuleClass parent_class;
};

struct _ValaDovaControlFlowModule {
	ValaDovaMethodModule parent_instance;
	ValaDovaControlFlowModulePrivate * priv;
};

struct _ValaDovaControlFlowModuleClass {
	ValaDovaMethodModuleClass parent_class;
};


static gpointer vala_dova_control_flow_module_parent_class = NULL;

GType vala_dova_base_module_get_type (void) G_GNUC_CONST;
gpointer vala_dova_base_module_emit_context_ref (gpointer instance);
void vala_dova_base_module_emit_context_unref (gpointer instance);
GParamSpec* vala_dova_base_module_param_spec_emit_context (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_dova_base_module_value_set_emit_context (GValue* value, gpointer v_object);
void vala_dova_base_module_value_take_emit_context (GValue* value, gpointer v_object);
gpointer vala_dova_base_module_value_get_emit_context (const GValue* value);
GType vala_dova_base_module_emit_context_get_type (void) G_GNUC_CONST;
GType vala_dova_struct_module_get_type (void) G_GNUC_CONST;
GType vala_dova_method_module_get_type (void) G_GNUC_CONST;
GType vala_dova_control_flow_module_get_type (void) G_GNUC_CONST;
enum  {
	VALA_DOVA_CONTROL_FLOW_MODULE_DUMMY_PROPERTY
};
static void vala_dova_control_flow_module_real_visit_if_statement (ValaCodeVisitor* base, ValaIfStatement* stmt);
ValaCCodeFunction* vala_dova_base_module_get_ccode (ValaDovaBaseModule* self);
ValaCCodeExpression* vala_dova_base_module_get_cvalue (ValaDovaBaseModule* self, ValaExpression* expr);
static void vala_dova_control_flow_module_real_visit_switch_statement (ValaCodeVisitor* base, ValaSwitchStatement* stmt);
static void vala_dova_control_flow_module_real_visit_switch_label (ValaCodeVisitor* base, ValaSwitchLabel* label);
static void vala_dova_control_flow_module_real_visit_loop (ValaCodeVisitor* base, ValaLoop* stmt);
static void vala_dova_control_flow_module_real_visit_break_statement (ValaCodeVisitor* base, ValaBreakStatement* stmt);
void vala_dova_base_module_append_local_free (ValaDovaBaseModule* self, ValaSymbol* sym, gboolean stop_at_loop, ValaCodeNode* stop_at);
ValaSymbol* vala_dova_base_module_get_current_symbol (ValaDovaBaseModule* self);
static void vala_dova_control_flow_module_real_visit_continue_statement (ValaCodeVisitor* base, ValaContinueStatement* stmt);
ValaDovaControlFlowModule* vala_dova_control_flow_module_construct (GType object_type);
ValaDovaMethodModule* vala_dova_method_module_construct (GType object_type);


static void vala_dova_control_flow_module_real_visit_if_statement (ValaCodeVisitor* base, ValaIfStatement* stmt) {
	ValaDovaControlFlowModule * self;
	ValaCCodeFunction* _tmp0_;
	ValaCCodeFunction* _tmp1_;
	ValaIfStatement* _tmp2_;
	ValaExpression* _tmp3_;
	ValaExpression* _tmp4_;
	ValaCCodeExpression* _tmp5_ = NULL;
	ValaCCodeExpression* _tmp6_;
	ValaIfStatement* _tmp7_;
	ValaBlock* _tmp8_;
	ValaBlock* _tmp9_;
	ValaIfStatement* _tmp10_;
	ValaBlock* _tmp11_;
	ValaBlock* _tmp12_;
	ValaCCodeFunction* _tmp18_;
	ValaCCodeFunction* _tmp19_;
	self = (ValaDovaControlFlowModule*) base;
	g_return_if_fail (stmt != NULL);
	_tmp0_ = vala_dova_base_module_get_ccode ((ValaDovaBaseModule*) self);
	_tmp1_ = _tmp0_;
	_tmp2_ = stmt;
	_tmp3_ = vala_if_statement_get_condition (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = vala_dova_base_module_get_cvalue ((ValaDovaBaseModule*) self, _tmp4_);
	_tmp6_ = _tmp5_;
	vala_ccode_function_open_if (_tmp1_, _tmp6_);
	_vala_ccode_node_unref0 (_tmp6_);
	_tmp7_ = stmt;
	_tmp8_ = vala_if_statement_get_true_statement (_tmp7_);
	_tmp9_ = _tmp8_;
	vala_code_node_emit ((ValaCodeNode*) _tmp9_, (ValaCodeGenerator*) self);
	_tmp10_ = stmt;
	_tmp11_ = vala_if_statement_get_false_statement (_tmp10_);
	_tmp12_ = _tmp11_;
	if (_tmp12_ != NULL) {
		ValaCCodeFunction* _tmp13_;
		ValaCCodeFunction* _tmp14_;
		ValaIfStatement* _tmp15_;
		ValaBlock* _tmp16_;
		ValaBlock* _tmp17_;
		_tmp13_ = vala_dova_base_module_get_ccode ((ValaDovaBaseModule*) self);
		_tmp14_ = _tmp13_;
		vala_ccode_function_add_else (_tmp14_);
		_tmp15_ = stmt;
		_tmp16_ = vala_if_statement_get_false_statement (_tmp15_);
		_tmp17_ = _tmp16_;
		vala_code_node_emit ((ValaCodeNode*) _tmp17_, (ValaCodeGenerator*) self);
	}
	_tmp18_ = vala_dova_base_module_get_ccode ((ValaDovaBaseModule*) self);
	_tmp19_ = _tmp18_;
	vala_ccode_function_close (_tmp19_);
}


static void vala_dova_control_flow_module_real_visit_switch_statement (ValaCodeVisitor* base, ValaSwitchStatement* stmt) {
	ValaDovaControlFlowModule * self;
	ValaCCodeFunction* _tmp0_;
	ValaCCodeFunction* _tmp1_;
	ValaSwitchStatement* _tmp2_;
	ValaExpression* _tmp3_;
	ValaExpression* _tmp4_;
	ValaCCodeExpression* _tmp5_ = NULL;
	ValaCCodeExpression* _tmp6_;
	ValaCCodeFunction* _tmp23_;
	ValaCCodeFunction* _tmp24_;
	self = (ValaDovaControlFlowModule*) base;
	g_return_if_fail (stmt != NULL);
	_tmp0_ = vala_dova_base_module_get_ccode ((ValaDovaBaseModule*) self);
	_tmp1_ = _tmp0_;
	_tmp2_ = stmt;
	_tmp3_ = vala_switch_statement_get_expression (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = vala_dova_base_module_get_cvalue ((ValaDovaBaseModule*) self, _tmp4_);
	_tmp6_ = _tmp5_;
	vala_ccode_function_open_switch (_tmp1_, _tmp6_);
	_vala_ccode_node_unref0 (_tmp6_);
	{
		ValaSwitchStatement* _tmp7_;
		ValaList* _tmp8_ = NULL;
		ValaList* _section_list;
		ValaList* _tmp9_;
		gint _tmp10_;
		gint _tmp11_;
		gint _section_size;
		gint _section_index;
		_tmp7_ = stmt;
		_tmp8_ = vala_switch_statement_get_sections (_tmp7_);
		_section_list = _tmp8_;
		_tmp9_ = _section_list;
		_tmp10_ = vala_collection_get_size ((ValaCollection*) _tmp9_);
		_tmp11_ = _tmp10_;
		_section_size = _tmp11_;
		_section_index = -1;
		while (TRUE) {
			gint _tmp12_;
			gint _tmp13_;
			gint _tmp14_;
			ValaList* _tmp15_;
			gint _tmp16_;
			gpointer _tmp17_ = NULL;
			ValaSwitchSection* section;
			ValaSwitchSection* _tmp18_;
			gboolean _tmp19_ = FALSE;
			ValaSwitchSection* _tmp22_;
			_tmp12_ = _section_index;
			_section_index = _tmp12_ + 1;
			_tmp13_ = _section_index;
			_tmp14_ = _section_size;
			if (!(_tmp13_ < _tmp14_)) {
				break;
			}
			_tmp15_ = _section_list;
			_tmp16_ = _section_index;
			_tmp17_ = vala_list_get (_tmp15_, _tmp16_);
			section = (ValaSwitchSection*) _tmp17_;
			_tmp18_ = section;
			_tmp19_ = vala_switch_section_has_default_label (_tmp18_);
			if (_tmp19_) {
				ValaCCodeFunction* _tmp20_;
				ValaCCodeFunction* _tmp21_;
				_tmp20_ = vala_dova_base_module_get_ccode ((ValaDovaBaseModule*) self);
				_tmp21_ = _tmp20_;
				vala_ccode_function_add_default (_tmp21_);
			}
			_tmp22_ = section;
			vala_code_node_emit ((ValaCodeNode*) _tmp22_, (ValaCodeGenerator*) self);
			_vala_code_node_unref0 (section);
		}
		_vala_iterable_unref0 (_section_list);
	}
	_tmp23_ = vala_dova_base_module_get_ccode ((ValaDovaBaseModule*) self);
	_tmp24_ = _tmp23_;
	vala_ccode_function_close (_tmp24_);
}


static void vala_dova_control_flow_module_real_visit_switch_label (ValaCodeVisitor* base, ValaSwitchLabel* label) {
	ValaDovaControlFlowModule * self;
	ValaSwitchLabel* _tmp0_;
	ValaExpression* _tmp1_;
	ValaExpression* _tmp2_;
	self = (ValaDovaControlFlowModule*) base;
	g_return_if_fail (label != NULL);
	_tmp0_ = label;
	_tmp1_ = vala_switch_label_get_expression (_tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_ != NULL) {
		ValaSwitchLabel* _tmp3_;
		ValaExpression* _tmp4_;
		ValaExpression* _tmp5_;
		ValaSwitchLabel* _tmp6_;
		ValaExpression* _tmp7_;
		ValaExpression* _tmp8_;
		ValaCCodeFunction* _tmp9_;
		ValaCCodeFunction* _tmp10_;
		ValaSwitchLabel* _tmp11_;
		ValaExpression* _tmp12_;
		ValaExpression* _tmp13_;
		ValaCCodeExpression* _tmp14_ = NULL;
		ValaCCodeExpression* _tmp15_;
		_tmp3_ = label;
		_tmp4_ = vala_switch_label_get_expression (_tmp3_);
		_tmp5_ = _tmp4_;
		vala_code_node_emit ((ValaCodeNode*) _tmp5_, (ValaCodeGenerator*) self);
		_tmp6_ = label;
		_tmp7_ = vala_switch_label_get_expression (_tmp6_);
		_tmp8_ = _tmp7_;
		vala_code_visitor_visit_end_full_expression ((ValaCodeVisitor*) self, _tmp8_);
		_tmp9_ = vala_dova_base_module_get_ccode ((ValaDovaBaseModule*) self);
		_tmp10_ = _tmp9_;
		_tmp11_ = label;
		_tmp12_ = vala_switch_label_get_expression (_tmp11_);
		_tmp13_ = _tmp12_;
		_tmp14_ = vala_dova_base_module_get_cvalue ((ValaDovaBaseModule*) self, _tmp13_);
		_tmp15_ = _tmp14_;
		vala_ccode_function_add_case (_tmp10_, _tmp15_);
		_vala_ccode_node_unref0 (_tmp15_);
	}
}


static void vala_dova_control_flow_module_real_visit_loop (ValaCodeVisitor* base, ValaLoop* stmt) {
	ValaDovaControlFlowModule * self;
	ValaCCodeFunction* _tmp0_;
	ValaCCodeFunction* _tmp1_;
	ValaCCodeConstant* _tmp2_;
	ValaCCodeConstant* _tmp3_;
	ValaLoop* _tmp4_;
	ValaBlock* _tmp5_;
	ValaBlock* _tmp6_;
	ValaCCodeFunction* _tmp7_;
	ValaCCodeFunction* _tmp8_;
	self = (ValaDovaControlFlowModule*) base;
	g_return_if_fail (stmt != NULL);
	_tmp0_ = vala_dova_base_module_get_ccode ((ValaDovaBaseModule*) self);
	_tmp1_ = _tmp0_;
	_tmp2_ = vala_ccode_constant_new ("true");
	_tmp3_ = _tmp2_;
	vala_ccode_function_open_while (_tmp1_, (ValaCCodeExpression*) _tmp3_);
	_vala_ccode_node_unref0 (_tmp3_);
	_tmp4_ = stmt;
	_tmp5_ = vala_loop_get_body (_tmp4_);
	_tmp6_ = _tmp5_;
	vala_code_node_emit ((ValaCodeNode*) _tmp6_, (ValaCodeGenerator*) self);
	_tmp7_ = vala_dova_base_module_get_ccode ((ValaDovaBaseModule*) self);
	_tmp8_ = _tmp7_;
	vala_ccode_function_close (_tmp8_);
}


static void vala_dova_control_flow_module_real_visit_break_statement (ValaCodeVisitor* base, ValaBreakStatement* stmt) {
	ValaDovaControlFlowModule * self;
	ValaSymbol* _tmp0_;
	ValaSymbol* _tmp1_;
	ValaCCodeFunction* _tmp2_;
	ValaCCodeFunction* _tmp3_;
	self = (ValaDovaControlFlowModule*) base;
	g_return_if_fail (stmt != NULL);
	_tmp0_ = vala_dova_base_module_get_current_symbol ((ValaDovaBaseModule*) self);
	_tmp1_ = _tmp0_;
	vala_dova_base_module_append_local_free ((ValaDovaBaseModule*) self, _tmp1_, TRUE, NULL);
	_tmp2_ = vala_dova_base_module_get_ccode ((ValaDovaBaseModule*) self);
	_tmp3_ = _tmp2_;
	vala_ccode_function_add_break (_tmp3_);
}


static void vala_dova_control_flow_module_real_visit_continue_statement (ValaCodeVisitor* base, ValaContinueStatement* stmt) {
	ValaDovaControlFlowModule * self;
	ValaSymbol* _tmp0_;
	ValaSymbol* _tmp1_;
	ValaCCodeFunction* _tmp2_;
	ValaCCodeFunction* _tmp3_;
	self = (ValaDovaControlFlowModule*) base;
	g_return_if_fail (stmt != NULL);
	_tmp0_ = vala_dova_base_module_get_current_symbol ((ValaDovaBaseModule*) self);
	_tmp1_ = _tmp0_;
	vala_dova_base_module_append_local_free ((ValaDovaBaseModule*) self, _tmp1_, TRUE, NULL);
	_tmp2_ = vala_dova_base_module_get_ccode ((ValaDovaBaseModule*) self);
	_tmp3_ = _tmp2_;
	vala_ccode_function_add_continue (_tmp3_);
}


ValaDovaControlFlowModule* vala_dova_control_flow_module_construct (GType object_type) {
	ValaDovaControlFlowModule* self = NULL;
	self = (ValaDovaControlFlowModule*) vala_dova_method_module_construct (object_type);
	return self;
}


static void vala_dova_control_flow_module_class_init (ValaDovaControlFlowModuleClass * klass) {
	vala_dova_control_flow_module_parent_class = g_type_class_peek_parent (klass);
	VALA_CODE_VISITOR_CLASS (klass)->visit_if_statement = vala_dova_control_flow_module_real_visit_if_statement;
	VALA_CODE_VISITOR_CLASS (klass)->visit_switch_statement = vala_dova_control_flow_module_real_visit_switch_statement;
	VALA_CODE_VISITOR_CLASS (klass)->visit_switch_label = vala_dova_control_flow_module_real_visit_switch_label;
	VALA_CODE_VISITOR_CLASS (klass)->visit_loop = vala_dova_control_flow_module_real_visit_loop;
	VALA_CODE_VISITOR_CLASS (klass)->visit_break_statement = vala_dova_control_flow_module_real_visit_break_statement;
	VALA_CODE_VISITOR_CLASS (klass)->visit_continue_statement = vala_dova_control_flow_module_real_visit_continue_statement;
}


static void vala_dova_control_flow_module_instance_init (ValaDovaControlFlowModule * self) {
}


GType vala_dova_control_flow_module_get_type (void) {
	static volatile gsize vala_dova_control_flow_module_type_id__volatile = 0;
	if (g_once_init_enter (&vala_dova_control_flow_module_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ValaDovaControlFlowModuleClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) vala_dova_control_flow_module_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValaDovaControlFlowModule), 0, (GInstanceInitFunc) vala_dova_control_flow_module_instance_init, NULL };
		GType vala_dova_control_flow_module_type_id;
		vala_dova_control_flow_module_type_id = g_type_register_static (VALA_TYPE_DOVA_METHOD_MODULE, "ValaDovaControlFlowModule", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&vala_dova_control_flow_module_type_id__volatile, vala_dova_control_flow_module_type_id);
	}
	return vala_dova_control_flow_module_type_id__volatile;
}



